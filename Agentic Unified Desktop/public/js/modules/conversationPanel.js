import { fetchInsightsFromServer } from '../api.js';
import {
	API_ENDPOINTS,
	DEFAULT_CUSTOMER_ID,
	WIDGETS_ON_AGENT_MESSAGE,
	GRADER_CONFIG,
	CHAT_UI,
	RICH_TEXT_STYLES,
	EVENTS,
	ROLES,
	getActiveCustomerIdSafe
} from '../config/appConfig.js';

const chatLog = document.getElementById('messages');
const chatInput = document.getElementById('chat-input');
const sendBtn = document.getElementById('send-btn');
const graderWidget = document.getElementById('response-grader-widget');
const gradeTone = document.getElementById('grade-tone');
const gradeClarity = document.getElementById('grade-clarity');
const gradeEmpathy = document.getElementById('grade-empathy');

let conversationHistory = [];

// Precompile empathy regex from config
const EMPATHY_REGEX = new RegExp(GRADER_CONFIG.empathy.keywords.join('|'), 'gi');

function formatRichText(raw){
  // Escape basic HTML then apply lightweight markdown-ish transforms
  let txt = raw.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  // Headings (lines starting with #)
  txt = txt.replace(/^#{1,3}\s*(.+)$/gm, (m,p)=>`<strong style="${RICH_TEXT_STYLES.heading}">${p}</strong>`);
  // Bullet lists (- or * ) into UL
  txt = txt.replace(/(?:^(?:-|\*) .+(?:\n|$)){1,}/gm, block => {
    const items = block.trim().split(/\n/).map(line=> line.replace(/^(?:-|\*)\s+/, '')).filter(Boolean);
    return `<ul class="msg-list">${items.map(i=>`<li>${i}</li>`).join('')}</ul>`;
  });
  // Numbered lists
  txt = txt.replace(/(?:^(?:\d+)\. .+(?:\n|$)){1,}/gm, block => {
    const items = block.trim().split(/\n/).map(line=> line.replace(/^\d+\.\s+/, '')).filter(Boolean);
    return `<ol class="msg-list num">${items.map(i=>`<li>${i}</li>`).join('')}</ol>`;
  });
  // Simple tables (| delimited)
  if (/^\s*\|.*\|/m.test(txt)){
    txt = txt.replace(/((?:^\|.*\|.*\n?)+)/gm, tbl => {
      const rows = tbl.trim().split(/\n/).map(r=> r.split('|').slice(1,-1).map(c=>c.trim()));
      if (!rows.length) return tbl;
      const header = rows[0];
      const body = rows.slice(1);
      return `<table class="msg-table"><thead><tr>${header.map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>${body.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('')}</tbody></table>`;
    });
  }
  txt = txt.replace(/\n{2,}/g, '</p><p>');
  txt = txt.replace(/\n/g, '<br/>');
  return `<p>${txt}</p>`;
}

function addMessage(role, content) {
  conversationHistory.push({ role, content });
  const div = document.createElement('div');
  div.className = `message ${role === ROLES.agent ? 'agent' : 'customer'}`;
  div.innerHTML = formatRichText(content);
  chatLog.appendChild(div);
  void div.offsetWidth; // force reflow for animation reliability
  chatLog.scrollTop = chatLog.scrollHeight;
  window.dispatchEvent(new CustomEvent(EVENTS.conversationChanged, { detail: { conversationHistory } }));
}

// Add a customer message coming from external system (SSE) while preventing duplicates
function addExternalMessage(content) {
  const last = conversationHistory[conversationHistory.length - 1];
  if (last && last.role === ROLES.customer && last.content === content) return; // dedupe
  addMessage(ROLES.customer, content);
}

// Insert an agent (assistant) message generated by the engine; de-duplicate identical repeats
function addAgentAutoMessage(content) {
  if (!content) return;
  const last = conversationHistory[conversationHistory.length - 1];
  if (last && last.role === ROLES.agent && last.content === content) return;
  addMessage(ROLES.agent, content);
}

function gradeResponse(text) {
	if (!text.trim()) { graderWidget.classList.add('hidden'); return; }
	graderWidget.classList.remove('hidden');
	const matches = text.match(EMPATHY_REGEX) || [];
	let empathyScore = matches.length * GRADER_CONFIG.empathy.weightPerMatch;
	const { warning, negative } = GRADER_CONFIG.thresholds;
	const set = (el, score) => {
		const clamped = Math.min(100, score);
		el.style.width = clamped + '%';
		let color = 'var(--accent-positive)';
		if (clamped < warning) color = 'var(--accent-warning)';
		if (clamped < negative) color = 'var(--accent-negative)';
		el.style.background = color;
	};
	set(gradeEmpathy, empathyScore);
	const clarity = Math.max(GRADER_CONFIG.clarity.min, GRADER_CONFIG.clarity.base - Math.abs(GRADER_CONFIG.clarity.base - text.length) / 2);
	set(gradeClarity, clarity);
	set(gradeTone, GRADER_CONFIG.toneDefault);
}

async function sendAgentMessage() {
  const text = chatInput.value.trim();
  if (!text) return;
  addMessage(ROLES.agent, text);
  chatInput.value = '';
  gradeResponse('');
  const customerId = getActiveCustomerIdSafe();
  try {
    await fetch(API_ENDPOINTS.agentReply, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ customerId, message: text })
    });
  } catch (e) {
    console.warn('Failed to broadcast agent reply', e);
  }
  try {
    const partial = await fetchInsightsFromServer({
      customerId,
      conversationHistory,
      requestedWidgets: WIDGETS_ON_AGENT_MESSAGE
    });
    const evt = new CustomEvent(EVENTS.insightsPartialUpdate, { detail: partial });
    window.dispatchEvent(evt);
  } catch (e) {
    console.warn('Partial insights update failed', e);
  }
}

function init() {
  sendBtn.addEventListener('click', sendAgentMessage);
  chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendAgentMessage(); }});
  chatInput.addEventListener('input', () => { gradeResponse(chatInput.value); });
  // Configure input box sizing from config
  chatInput.style.minHeight = CHAT_UI.inputMinHeightPx + 'px';
  chatInput.style.resize = CHAT_UI.inputResize;
  // Expose conversation for other modules (e.g. ServicePedia article expansion)
  window.conversationHistory = conversationHistory;
  window.addEventListener(EVENTS.insertPromptToChat, (e) => {
    chatInput.value += (chatInput.value ? ' ' : '') + e.detail.value;
    chatInput.focus();
    gradeResponse(chatInput.value);
  });
  window.addEventListener(EVENTS.insertComposerText, (e) => {
    chatInput.value = e.detail.value;
    chatInput.focus();
    gradeResponse(chatInput.value);
  });
  // no seed; waits for external chat or agent input
}

export { init, conversationHistory, addExternalMessage, addAgentAutoMessage };
